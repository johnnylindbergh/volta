
// how deep in the expanded start node's stream to look
// for sentences structures of appropriate length.
const EXPANSION_PREFIX = 2000;

class CFG {
  constructor(_startLabel, _labelToNode) {
    this.startLabel = _startLabel;
    this.labelToNode = _labelToNode;
  }

  // retrieve the grammar's start node, using its label
  getStartNode() {
    return this.labelToNode[this.startLabel];
  }

  // generate sentence structures produced by the grammar, 
  // bounded by a given length.
  sentStructs(maxLen) {
    // construct infinite stream of structures generated by start symbol
    let rootExpansion = expand(this.getStartNode(), this);

    // take a finite prefix and filter out those too long
    return take(rootExpansion, EXPANSION_PREFIX)
      .filter((struct) => struct.length <= maxLen);
  }
}

class CFGNode {}

class NonTerminal extends CFGNode {
  constructor(_label, _expansions) {
    super();
    this.label = _label;
    this.expansions = _expansions;
  }
}

class Terminal extends CFGNode {
  constructor(_label) {
    super();
    this.label = _label;
    this.isTerminal = true;
  }
}

class Literal extends CFGNode {
  constructor(_content) {
    super();
    this.content = _content;
    this.isLiteral = true;
  }
}

// ============================================================================
// The following operations facilitate the generation of strings in the 
// language of the CFG. Because terminals of the CFG represent parts of 
// speech, strings in the language are abstract sentence structures.
//
// Because the grammar is recursive, its language is infinite. To expand
// the CFG's start node into strings it derives, we use lazy streams.
// ============================================================================

class Stream {
  constructor(_first, _rest) {
    this.isEmpty = _first == undefined && _rest == undefined;
    this.first = _first;
    this.rest = _rest;
  }
}

// Force a thunk by calling it
function force(thunk) {
  return thunk();
}

// Union streams a and b, interleaving their elements.
// Expects second parameter to be a thunked stream, only evaluated
// when the rest() of the union stream is taken.
function lazyStreamUnion(a, bThunk) {
  // if a is empty, need to evaluate the b stream now
  if (a.isEmpty) {
    return force(bThunk);
  }

  return new Stream(a.first,
      // rest() forces b's thunk, yields a stream starting with
      // b's first element and continuing the lazy union
      () => {
        let b = force(bThunk);
        if (b.isEmpty) { return a.rest(); }

        return new Stream(b.first,
          () => lazyStreamUnion(a.rest(), () => b.rest()));
      });
}

// Convert an array into a stream that ends in the given rest of stream.
function toStream(prefix, thunkedRest) {
  if (prefix.length == 0) {
    return thunkedRest();
  }

  let first = prefix[0];
  prefix.shift();

  return new Stream(first, () => toStream(prefix, thunkedRest));
}

// Take the product of two streams of sentence structures, concatenating
// every structure from a in front of every structure from b.
function streamProduct(a, b) {
  return streamProdPrefix(a, b, [], []);
}

// Adapted from https://www.reddit.com/r/math/comments/6o5tq3/
// software_maths_cartesian_product_of_infinite_sets/
function streamProdPrefix(a, b, aPrefix, bPrefix) {
  if (a.isEmpty && b.isEmpty) return new Stream();

  if (a.isEmpty && aPrefix.length == 0) {
    return b;
  }
  if (b.isEmpty && bPrefix.length == 0) {
    return a;
  }

  let newFromA = a.first;
  let newFromB = b.first;
  let newStructures = [];

  // pair new B element with every elt in a's prefix
  if (newFromB) {
    for (var i = 0; i < aPrefix.length; i++) {
      newStructures.push(aPrefix[i].concat(newFromB));
    }
  }
  // pair new A element with every elt in b's prefix
  if (newFromA) {
    for (var i = 0; i < bPrefix.length; i++) {
      newStructures.push(newFromA.concat(bPrefix[i]));
    }
  }
  // pair new a and b elements
  if (newFromA && newFromB) {
    newStructures.push(newFromA.concat(newFromB));
  }

  // extend prefixes
  if (newFromA) aPrefix.push(newFromA);
  if (newFromB) bPrefix.push(newFromB);

  // return rest of product appended to this portion of product
  return toStream(newStructures,
    () => streamProdPrefix( a.isEmpty ? a : a.rest(), 
                            b.isEmpty ? b : b.rest(), 
                            aPrefix, bPrefix));
}

// Construct (potentially infinite) stream of  all sentences generated 
// by this node. Note: Assumes first expansion of a non-terminal is 
// non-recursive.
// Adapted from https://math.stackexchange.com/questions/36403/generating-all
// -words-in-a-language-from-cfg
function expand(node, grammar) {
  // terminals form a sentence of just themselves
  if (node.isTerminal || node.isLiteral) {
    return new Stream([node], () => new Stream());
  }

  let unionOfExpansions = new Stream();

  // for each expansion of this node
  for (var i = 0; i < node.expansions.length; i++) {
    let variant = node.expansions[i];

    // thunk the computation that computes the cross product
    // of every child node within this expansion RHS
    // (may be recursive, so must thunk)
    let productThunk = () => {
      let productOfChildNodes = new Stream();
      for (var j = 0; j < variant.length; j++) {
        let childNode = grammar.labelToNode[variant[j]];

        productOfChildNodes = streamProduct(productOfChildNodes, 
          expand(childNode, grammar));
      }
      return productOfChildNodes;
    };

    // union (lazily) this product with the running union so far
    unionOfExpansions = lazyStreamUnion(unionOfExpansions, productThunk);
  }

  return unionOfExpansions;
}

// Retrieves a finite prefix of a given length from a stream,
// or the longest prefix possible, if the stream is too short.
function take(stream, n) {
  let segment = [];
  for (var i = 0; i < n; i++) {
    if (stream.isEmpty) {
      return segment;
    }

    segment.push(stream.first);
    stream = stream.rest();
  }

  return segment;
}

module.exports = {
  CFG, NonTerminal, Terminal, Literal
}