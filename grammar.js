/*

Sentence ::=  NP1stSg VP1stSg
            | NP2ndSg VP2ndSg
            | NP3rdSg VP3rdSg
            | NP1stPl VP1stPl
            | NP2ndPl VP2ndPl
            | NP3rdPl VP3rdPl


            NP1

NP1stSg ::= PN1stSg

VP1stSg ::= 


NP3rdSg ::= Article Noun
        | ProperNoun

Noun ::= Noun
      | Adj Noun
      | Noun PrepPhrase

PrepPhrase ::= Prep Object
   
https://www.scientificpsychic.com/grammar/enggram6.html
*/

class Stream {
  constructor(_first, _rest) {
    this.isEmpty = _first == undefined && _rest == undefined;
    this.first = _first;
    this.rest = _rest;
  }
}

class CFGNode {
  constructor(_label, _isTerminal, _expansions) {
    this.label = _label;
    this.isTerminal = _isTerminal;
    this.expansions = _expansions;
  }
}

class CFG {
  constructor(_startLabel, _labelToNode) {
    this.startLabel = _startLabel;
    this.labelToNode = _labelToNode;
  }
}

// Force a thunk by calling it
function force(thunk) {
  return thunk();
}

// Union streams a and b, interleaving their elements.
// Expects second parameter to be a thunked stream, only evaluated
// when the rest() of the union stream is taken.
function lazyStreamUnion(a, bThunk) {
  // if a is empty, need to evaluate the b stream now
  if (a.isEmpty) {
    return force(bThunk);
  }

  return new Stream(a.first,
      // rest() forces b's thunk, yields a stream starting with
      // b's first element and continuing the lazy union
      () => {
        let b = force(bThunk);
        if (b.isEmpty) { return a.rest(); }

        return new Stream(b.first,
          () => lazyStreamUnion(a.rest(), () => b.rest()));
      });
}

// Convert an array into a stream that ends in the given rest of stream.
function toStream(prefix, thunkedRest) {
  if (prefix.length == 0) {
    return thunkedRest();
  }

  let first = prefix[0];
  prefix.shift();

  return new Stream(first, () => toStream(prefix, thunkedRest));
}

// Take the product of two streams of sentence structures, concatenating
// every structure from a in front of every structure from b.
function streamProduct(a, b) {
  return streamProdPrefix(a, b, [], []);
}

// Adapted from https://www.reddit.com/r/math/comments/6o5tq3/
// software_maths_cartesian_product_of_infinite_sets/
function streamProdPrefix(a, b, aPrefix, bPrefix) {
  if (a.isEmpty && b.isEmpty) return new Stream();

  if (a.isEmpty && aPrefix.length == 0) {
    return b;
  }
  if (b.isEmpty && bPrefix.length == 0) {
    return a;
  }

  let newFromA = a.first;
  let newFromB = b.first;
  let newStructures = [];

  // pair new B element with every elt in a's prefix
  if (newFromB) {
    for (var i = 0; i < aPrefix.length; i++) {
      newStructures.push(aPrefix[i].concat(newFromB));
    }
  }
  // pair new A element with every elt in b's prefix
  if (newFromA) {
    for (var i = 0; i < bPrefix.length; i++) {
      newStructures.push(newFromA.concat(bPrefix[i]));
    }
  }
  // pair new a and b elements
  if (newFromA && newFromB) {
    newStructures.push(newFromA.concat(newFromB));
  }

  // extend prefixes
  if (newFromA) aPrefix.push(newFromA);
  if (newFromB) bPrefix.push(newFromB);

  // return rest of product appended to this portion of product
  return toStream(newStructures,
    () => streamProdPrefix( a.isEmpty ? a : a.rest(), 
                            b.isEmpty ? b : b.rest(), 
                            aPrefix, bPrefix));
}

// Construct (potentially infinite) stream of 
// all sentences generated by this node
// Note: Assumes first expansion of a non-terminal is non-recursive.
// Adapted from https://math.stackexchange.com/questions/36403/
// generating-all-words-in-a-language-from-cfg
function expand(node, grammar) {
  // terminals form a sentence of just themselves
  if (node.isTerminal) {
    return new Stream([node.label], () => new Stream());
  }

  let unionOfExpansions = new Stream();

  // for each expansion of this node
  for (var i = 0; i < node.expansions.length; i++) {
    let variant = node.expansions[i];

    // thunk the computation that computes the cross product
    // of every child node within this expansion RHS
    // (may be recursive, so must thunk)
    let productThunk = () => {
      let productOfChildNodes = new Stream();
      for (var j = 0; j < variant.length; j++) {
        let childNode = grammar.labelToNode[variant[j]];

        productOfChildNodes = streamProduct(productOfChildNodes, 
          expand(childNode, grammar));
      }
      return productOfChildNodes;
    };

    // union (lazily) this product with the running union so far
    unionOfExpansions = lazyStreamUnion(unionOfExpansions, productThunk);
  }

  return unionOfExpansions;

  // return node.expansions.reduce((union, rhs) => {
  //   return lazyStreamUnion(union, 
  //     () => {
  //       return rhs.reduce((prod, label) => {
  //         let childNode = grammar.labelToNode[label];
  //         return streamProduct(prod, expand(childNode, grammar));
  //       }, new Stream());
  //     });
  // }, new Stream());
}

// Retrieves a finite prefix of a given length from a stream.
function take(stream, n) {
  let segment = [];
  for (var i = 0; i < n; i++) {
    if (stream.isEmpty) {
      throw Error(`Stream ran out after ${i} elements.`);
    }

    segment.push(stream.first);
    stream = stream.rest();
  }

  return segment;
}



// --------------------- example ---------------------
let g = new CFG('S', {
  'S':  new CFGNode('S', false, [['NP', 'VP']]),
  'NP': new CFGNode('NP', false, [['PN'], 
                                  ['Det', 'N']]),
  'VP': new CFGNode('VP', false, [['Vintr'],
                                  ['Adv', 'VP']]),
  'PN': new CFGNode('PN', true),
  'Det': new CFGNode('Det', true),
  'N':  new CFGNode('N', false, [['Noun'], 
                                  ['Adj', 'N']]),
  'Vintr': new CFGNode('Vintr', true),
  'Adv': new CFGNode('Adv', true),
  'Adj': new CFGNode('Adj', true),
  'Noun': new CFGNode('Noun', true)
});

let exp = expand(g.labelToNode['S'], g);
console.log(take(exp, 15));